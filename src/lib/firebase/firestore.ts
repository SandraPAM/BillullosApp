import { collection, addDoc, serverTimestamp, Timestamp, query, where, onSnapshot, doc, getDoc, updateDoc, increment, deleteDoc, writeBatch, getDocs } from "firebase/firestore"; 
import { db } from "./config";
import type { Budget, Expense } from "@/types";
import { deleteFileFromStorage } from "./storage";

// Type for the data to be added, excluding fields generated by Firestore
type AddBudgetData = Omit<Budget, 'id' | 'spentAmount' | 'deadline'> & {
  deadline: Date; // Expect Date object
};
/**
 * Adds a new budget document to the 'budgets' collection in Firestore.
 * @param budgetData The data for the new budget.
 * @returns A promise that resolves with the new document reference.
 */
export async function addBudget(budgetData: AddBudgetData) {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }
  try {
    const docRef = await addDoc(collection(db, "budgets"), {
      ...budgetData,
      deadline: Timestamp.fromDate(budgetData.deadline), // Convert Date to Timestamp
      spentAmount: 0, // Initialize spent amount to 0
      createdAt: serverTimestamp(),
    });
    return docRef;
  } catch (e) {
    console.error("Error adding document: ", e);
    throw new Error("Failed to add budget to Firestore.");
  }
}

/**
 * Listens for real-time updates to a user's budgets.
 * @param userId The ID of the user whose budgets to fetch.
 * @param callback A function to call with the updated budgets list.
 * @returns An unsubscribe function to stop listening for updates.
 */
export function onBudgetsUpdate(userId: string, callback: (budgets: Budget[]) => void) {
  if (!db) {
    console.error("Firestore is not initialized.");
    return () => {}; // Return a no-op unsubscribe function
  }
  
  const q = query(collection(db, "budgets"), where("userId", "==", userId));

  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const budgets: Budget[] = [];
    querySnapshot.forEach((doc) => {
      budgets.push({ id: doc.id, ...doc.data() } as Budget);
    });
    callback(budgets);
  }, (error) => {
    console.error("Error listening to budgets collection: ", error);
    // You might want to handle this error in the UI as well
  });

  return unsubscribe;
}

/**
 * Listens for real-time updates to a single budget.
 * @param budgetId The ID of the budget to fetch.
 * @param callback A function to call with the updated budget data.
 * @returns An unsubscribe function to stop listening for updates.
 */
export function onBudgetUpdate(budgetId: string, callback: (budget: Budget | null) => void) {
  if (!db) {
    console.error("Firestore is not initialized.");
    return () => {};
  }
  
  const docRef = doc(db, "budgets", budgetId);

  const unsubscribe = onSnapshot(docRef, (docSnap) => {
    if (docSnap.exists()) {
      callback({ id: docSnap.id, ...docSnap.data() } as Budget);
    } else {
      console.log("No such document!");
      callback(null);
    }
  }, (error) => {
    console.error("Error listening to budget document: ", error);
    callback(null);
  });

  return unsubscribe;
}

type AddExpenseData = Omit<Expense, 'id' | 'date' | 'budgetId'>;

/**
 * Adds a new expense and updates the corresponding budget's spent amount.
 * @param budgetId The ID of the budget this expense belongs to.
 * @param expenseData The data for the new expense.
 * @returns The ID of the newly created expense document.
 */
export async function addExpense(budgetId: string, expenseData: AddExpenseData): Promise<string> {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }
  
  const budgetRef = doc(db, "budgets", budgetId);
  const expenseCollRef = collection(db, "expenses");

  try {
    const expenseDocRef = await addDoc(expenseCollRef, {
      ...expenseData,
      budgetId: budgetId,
      date: serverTimestamp(),
    });

    // Atomically increment the spentAmount on the budget
    await updateDoc(budgetRef, {
      spentAmount: increment(expenseData.amount)
    });

    return expenseDocRef.id;

  } catch (e) {
    console.error("Error adding expense: ", e);
    throw new Error("Failed to add expense.");
  }
}

/**
 * Listens for real-time updates to expenses for a specific budget.
 * @param budgetId The ID of the budget whose expenses to fetch.
 * @param callback A function to call with the updated expenses list.
 * @returns An unsubscribe function to stop listening for updates.
 */
export function onExpensesUpdate(budgetId: string, callback: (expenses: Expense[]) => void) {
    if (!db) {
        console.error("Firestore is not initialized.");
        return () => {};
    }

    const q = query(collection(db, "expenses"), where("budgetId", "==", budgetId));

    const unsubscribe = onSnapshot(q, (querySnapshot) => {
        const expenses: Expense[] = [];
        querySnapshot.forEach((doc) => {
            expenses.push({ id: doc.id, ...doc.data() } as Expense);
        });
        callback(expenses);
    }, (error) => {
        console.error("Error listening to expenses collection: ", error);
    });

    return unsubscribe;
}

/**
 * Deletes a budget and all its associated expenses and receipts.
 * @param budgetId The ID of the budget to delete.
 */
export async function deleteBudget(budgetId: string) {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }

  const budgetRef = doc(db, "budgets", budgetId);
  const expensesQuery = query(collection(db, "expenses"), where("budgetId", "==", budgetId));

  try {
    const batch = writeBatch(db);
    const expensesSnapshot = await getDocs(expensesQuery);
    
    // Asynchronously delete all associated receipt files from Storage
    const deletePromises = expensesSnapshot.docs.map(doc => {
        const expense = doc.data() as Expense;
        if (expense.storagePath) {
            return deleteFileFromStorage(expense.storagePath);
        }
        return Promise.resolve();
    });
    
    await Promise.all(deletePromises);
    
    // Delete expense documents in a batch
    expensesSnapshot.forEach((doc) => {
      batch.delete(doc.ref);
    });

    // Delete the budget document
    batch.delete(budgetRef);

    // Commit the batch
    await batch.commit();
    console.log(`Budget ${budgetId} and all its expenses have been deleted.`);

  } catch (e) {
    console.error("Error deleting budget and expenses: ", e);
    throw new Error("Failed to delete budget.");
  }
}


type UpdateExpenseData = Partial<Omit<Expense, 'id' | 'date' | 'budgetId' | 'userId'>>;

/**
 * Updates an existing expense and adjusts the parent budget's spent amount.
 * @param expenseId The ID of the expense to update.
 * @param budgetId The ID of the parent budget.
 * @param oldAmount The original amount of the expense before updating.
 * @param newExpenseData The new data for the expense.
 */
export async function updateExpense(expenseId: string, budgetId: string, oldAmount: number, newExpenseData: UpdateExpenseData) {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }

  const expenseRef = doc(db, "expenses", expenseId);
  const budgetRef = doc(db, "budgets", budgetId);

  try {
    const amountDifference = (newExpenseData.amount ?? oldAmount) - oldAmount;

    const batch = writeBatch(db);
    
    // Update the expense document
    batch.update(expenseRef, newExpenseData);

    // Adjust the budget's spent amount if the amount changed
    if (amountDifference !== 0) {
      batch.update(budgetRef, {
        spentAmount: increment(amountDifference)
      });
    }

    await batch.commit();
  } catch (e) {
    console.error("Error updating expense:", e);
    throw new Error("Failed to update expense.");
  }
}

/**
 * Deletes a single expense and its receipt, and decrements the budget's spent amount.
 * @param expenseId The ID of the expense to delete.
 * @param budgetId The ID of the parent budget.
 * @param amount The amount of the expense being deleted.
 * @param storagePath The path to the receipt in Firebase Storage, if it exists.
 */
export async function deleteExpense(expenseId: string, budgetId: string, amount: number, storagePath?: string) {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }
  
  const expenseRef = doc(db, "expenses", expenseId);
  const budgetRef = doc(db, "budgets", budgetId);

  try {
    // Delete the receipt from storage if it exists
    if (storagePath) {
      await deleteFileFromStorage(storagePath);
    }
    
    const batch = writeBatch(db);

    // Delete the expense document
    batch.delete(expenseRef);

    // Decrement the spentAmount on the budget
    batch.update(budgetRef, {
        spentAmount: increment(-amount)
    });

    await batch.commit();
  } catch (e) {
    console.error("Error deleting expense:", e);
    throw new Error("Failed to delete expense.");
  }
}
