import { collection, addDoc, serverTimestamp, Timestamp, query, where, onSnapshot, doc, getDoc, updateDoc, increment, deleteDoc, writeBatch, getDocs } from "firebase/firestore"; 
import { db } from "./config";
import type { Budget, Expense } from "@/types";

// Type for the data to be added, excluding fields generated by Firestore
type AddBudgetData = Omit<Budget, 'id' | 'spentAmount' | 'deadline'> & {
  deadline: Date; // Expect Date object
};
/**
 * Adds a new budget document to the 'budgets' collection in Firestore.
 * @param budgetData The data for the new budget.
 * @returns A promise that resolves with the new document reference.
 */
export async function addBudget(budgetData: AddBudgetData) {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }
  try {
    const docRef = await addDoc(collection(db, "budgets"), {
      ...budgetData,
      deadline: Timestamp.fromDate(budgetData.deadline), // Convert Date to Timestamp
      spentAmount: 0, // Initialize spent amount to 0
      createdAt: serverTimestamp(),
    });
    return docRef;
  } catch (e) {
    console.error("Error adding document: ", e);
    throw new Error("Failed to add budget to Firestore.");
  }
}

/**
 * Listens for real-time updates to a user's budgets.
 * @param userId The ID of the user whose budgets to fetch.
 * @param callback A function to call with the updated budgets list.
 * @returns An unsubscribe function to stop listening for updates.
 */
export function onBudgetsUpdate(userId: string, callback: (budgets: Budget[]) => void) {
  if (!db) {
    console.error("Firestore is not initialized.");
    return () => {}; // Return a no-op unsubscribe function
  }
  
  const q = query(collection(db, "budgets"), where("userId", "==", userId));

  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const budgets: Budget[] = [];
    querySnapshot.forEach((doc) => {
      budgets.push({ id: doc.id, ...doc.data() } as Budget);
    });
    callback(budgets);
  }, (error) => {
    console.error("Error listening to budgets collection: ", error);
    // You might want to handle this error in the UI as well
  });

  return unsubscribe;
}

/**
 * Listens for real-time updates to a single budget.
 * @param budgetId The ID of the budget to fetch.
 * @param callback A function to call with the updated budget data.
 * @returns An unsubscribe function to stop listening for updates.
 */
export function onBudgetUpdate(budgetId: string, callback: (budget: Budget | null) => void) {
  if (!db) {
    console.error("Firestore is not initialized.");
    return () => {};
  }
  
  const docRef = doc(db, "budgets", budgetId);

  const unsubscribe = onSnapshot(docRef, (docSnap) => {
    if (docSnap.exists()) {
      callback({ id: docSnap.id, ...docSnap.data() } as Budget);
    } else {
      console.log("No such document!");
      callback(null);
    }
  }, (error) => {
    console.error("Error listening to budget document: ", error);
    callback(null);
  });

  return unsubscribe;
}

type AddExpenseData = Omit<Expense, 'id' | 'date' | 'budgetId'>;

/**
 * Adds a new expense and updates the corresponding budget's spent amount.
 * @param budgetId The ID of the budget this expense belongs to.
 * @param expenseData The data for the new expense.
 */
export async function addExpense(budgetId: string, expenseData: AddExpenseData) {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }
  
  const budgetRef = doc(db, "budgets", budgetId);

  try {
    // Add the new expense document
    await addDoc(collection(db, "expenses"), {
      ...expenseData,
      budgetId: budgetId,
      date: serverTimestamp(),
    });

    // Atomically increment the spentAmount on the budget
    await updateDoc(budgetRef, {
      spentAmount: increment(expenseData.amount)
    });

  } catch (e) {
    console.error("Error adding expense: ", e);
    throw new Error("Failed to add expense.");
  }
}

/**
 * Listens for real-time updates to expenses for a specific budget.
 * @param budgetId The ID of the budget whose expenses to fetch.
 * @param callback A function to call with the updated expenses list.
 * @returns An unsubscribe function to stop listening for updates.
 */
export function onExpensesUpdate(budgetId: string, callback: (expenses: Expense[]) => void) {
    if (!db) {
        console.error("Firestore is not initialized.");
        return () => {};
    }

    const q = query(collection(db, "expenses"), where("budgetId", "==", budgetId));

    const unsubscribe = onSnapshot(q, (querySnapshot) => {
        const expenses: Expense[] = [];
        querySnapshot.forEach((doc) => {
            expenses.push({ id: doc.id, ...doc.data() } as Expense);
        });
        callback(expenses);
    }, (error) => {
        console.error("Error listening to expenses collection: ", error);
    });

    return unsubscribe;
}

/**
 * Deletes a budget and all its associated expenses.
 * @param budgetId The ID of the budget to delete.
 */
export async function deleteBudget(budgetId: string) {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }

  const budgetRef = doc(db, "budgets", budgetId);
  const expensesQuery = query(collection(db, "expenses"), where("budgetId", "==", budgetId));

  try {
    // Start a batch write
    const batch = writeBatch(db);

    // Get all expenses for the budget
    const expensesSnapshot = await getDocs(expensesQuery);
    expensesSnapshot.forEach((doc) => {
      batch.delete(doc.ref); // Add each expense deletion to the batch
    });

    // Add the budget deletion to the batch
    batch.delete(budgetRef);

    // Commit the batch
    await batch.commit();
    console.log(`Budget ${budgetId} and all its expenses have been deleted.`);

  } catch (e) {
    console.error("Error deleting budget and expenses: ", e);
    throw new Error("Failed to delete budget.");
  }
}
