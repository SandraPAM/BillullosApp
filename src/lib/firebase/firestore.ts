
import { collection, addDoc, serverTimestamp, Timestamp, query, where, onSnapshot, doc, getDoc, updateDoc, increment, deleteDoc, writeBatch, getDocs } from "firebase/firestore"; 
import { db } from "./config";
import type { Budget, Expense, SavingsGoal, SavingsRecord } from "@/types";
import { deleteFileFromStorage } from "./storage";

// Type for the data to be added, excluding fields generated by Firestore
type AddBudgetData = Omit<Budget, 'id' | 'spentAmount' | 'deadline' | 'createdAt'> & {
  deadline: Date; // Expect Date object
};
/**
 * Adds a new budget document to the 'budgets' collection in Firestore.
 * @param budgetData The data for the new budget.
 * @returns A promise that resolves with the new document reference.
 */
export async function addBudget(budgetData: AddBudgetData) {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }
  try {
    const docRef = await addDoc(collection(db, "budgets"), {
      ...budgetData,
      deadline: Timestamp.fromDate(budgetData.deadline), // Convert Date to Timestamp
      spentAmount: 0, // Initialize spent amount to 0
      createdAt: serverTimestamp(),
    });
    return docRef;
  } catch (e) {
    console.error("Error adding document: ", e);
    throw new Error("Failed to add budget to Firestore.");
  }
}

/**
 * Listens for real-time updates to a user's budgets.
 * @param userId The ID of the user whose budgets to fetch.
 * @param callback A function to call with the updated budgets list.
 * @returns An unsubscribe function to stop listening for updates.
 */
export function onBudgetsUpdate(userId: string, callback: (budgets: Budget[]) => void) {
  if (!db) {
    console.error("Firestore is not initialized.");
    return () => {}; // Return a no-op unsubscribe function
  }
  
  const q = query(collection(db, "budgets"), where("userId", "==", userId));

  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const budgets: Budget[] = [];
    querySnapshot.forEach((doc) => {
      budgets.push({ id: doc.id, ...doc.data() } as Budget);
    });
    callback(budgets);
  }, (error) => {
    console.error("Error listening to budgets collection: ", error);
    // You might want to handle this error in the UI as well
  });

  return unsubscribe;
}

/**
 * Listens for real-time updates to a single budget.
 * @param budgetId The ID of the budget to fetch.
 * @param callback A function to call with the updated budget data.
 * @returns An unsubscribe function to stop listening for updates.
 */
export function onBudgetUpdate(budgetId: string, callback: (budget: Budget | null) => void) {
  if (!db) {
    console.error("Firestore is not initialized.");
    return () => {};
  }
  
  const docRef = doc(db, "budgets", budgetId);

  const unsubscribe = onSnapshot(docRef, (docSnap) => {
    if (docSnap.exists()) {
      callback({ id: docSnap.id, ...docSnap.data() } as Budget);
    } else {
      console.log("No such document!");
      callback(null);
    }
  }, (error) => {
    console.error("Error listening to budget document: ", error);
    callback(null);
  });

  return unsubscribe;
}

type AddExpenseData = Omit<Expense, 'id' | 'date' | 'budgetId'>;

/**
 * Adds a new expense document. Does NOT update the budget total.
 * This is used as the first step in a multi-step process.
 * @param budgetId The ID of the budget this expense belongs to.
 * @param expenseData The data for the new expense.
 * @returns The ID of the newly created expense document.
 */
export async function addExpense(budgetId: string, expenseData: AddExpenseData): Promise<string> {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }
  
  const expenseCollRef = collection(db, "expenses");

  try {
    const expenseDocRef = await addDoc(expenseCollRef, {
      ...expenseData,
      budgetId: budgetId,
      date: serverTimestamp(),
    });
    return expenseDocRef.id;
  } catch (e) {
    console.error("Error adding expense document: ", e);
    throw new Error("Failed to create expense document.");
  }
}

/**
 * Listens for real-time updates to expenses for a specific budget.
 * This query requires a composite index on (userId, budgetId).
 * @param budgetId The ID of the budget whose expenses to fetch.
 * @param userId The ID of the currently authenticated user.
 * @param callback A function to call with the updated expenses list.
 * @returns An unsubscribe function to stop listening for updates.
 */
export function onExpensesUpdate(budgetId: string, userId: string, callback: (expenses: Expense[]) => void) {
    if (!db) {
        console.error("Firestore is not initialized.");
        return () => {};
    }

    const q = query(
      collection(db, "expenses"),
      where("userId", "==", userId),
      where("budgetId", "==", budgetId)
    );

    const unsubscribe = onSnapshot(q, (querySnapshot) => {
        const expenses: Expense[] = [];
        querySnapshot.forEach((doc) => {
            expenses.push({ id: doc.id, ...doc.data() } as Expense);
        });
        callback(expenses);
    }, (error) => {
        console.error("Error listening to expenses collection: ", error);
    });

    return unsubscribe;
}

/**
 * Deletes a budget and all its associated expenses and receipts.
 * @param budgetId The ID of the budget to delete.
 */
export async function deleteBudget(budgetId: string) {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }

  const budgetRef = doc(db, "budgets", budgetId);

  try {
    // First, get the budget document to retrieve the userId
    const budgetDoc = await getDoc(budgetRef);
    if (!budgetDoc.exists()) {
      throw new Error("Budget to delete not found.");
    }
    const userId = budgetDoc.data().userId;

    // Now, query for expenses with both budgetId and userId
    const expensesQuery = query(
      collection(db, "expenses"),
      where("budgetId", "==", budgetId),
      where("userId", "==", userId)
    );
    
    const batch = writeBatch(db);
    const expensesSnapshot = await getDocs(expensesQuery);
    
    // Asynchronously delete all associated receipt files from Storage
    const deletePromises = expensesSnapshot.docs.map(doc => {
        const expense = doc.data() as Expense;
        if (expense.storagePath) {
            return deleteFileFromStorage(expense.storagePath);
        }
        return Promise.resolve();
    });
    
    await Promise.all(deletePromises);
    
    // Delete expense documents in a batch
    expensesSnapshot.forEach((doc) => {
      batch.delete(doc.ref);
    });

    // Delete the budget document
    batch.delete(budgetRef);

    // Commit the batch
    await batch.commit();
    console.log(`Budget ${budgetId} and all its expenses have been deleted.`);

  } catch (e) {
    console.error("Error deleting budget and expenses: ", e);
    throw new Error("Failed to delete budget.");
  }
}


type UpdateExpenseData = Partial<Omit<Expense, 'id' | 'date' | 'budgetId' | 'userId'>>;

/**
 * Updates an existing expense and adjusts the parent budget's spent amount.
 * @param expenseId The ID of the expense to update.
 * @param budgetId The ID of the parent budget.
 * @param oldAmount The original amount of the expense before updating. For new expenses, this should be 0.
 * @param newExpenseData The new data for the expense.
 */
export async function updateExpense(expenseId: string, budgetId: string, oldAmount: number, newExpenseData: UpdateExpenseData) {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }

  const expenseRef = doc(db, "expenses", expenseId);
  const budgetRef = doc(db, "budgets", budgetId);

  try {
    const finalUpdateData: { [key: string]: any } = {};
    if (newExpenseData.description !== undefined) finalUpdateData.description = newExpenseData.description;
    if (newExpenseData.amount !== undefined) finalUpdateData.amount = newExpenseData.amount;
    if (newExpenseData.receiptUrl !== undefined) finalUpdateData.receiptUrl = newExpenseData.receiptUrl;
    if (newExpenseData.storagePath !== undefined) finalUpdateData.storagePath = newExpenseData.storagePath;

    const amountDifference = (newExpenseData.amount ?? oldAmount) - oldAmount;

    const batch = writeBatch(db);
    
    if (Object.keys(finalUpdateData).length > 0) {
      batch.update(expenseRef, finalUpdateData);
    }

    if (amountDifference !== 0) {
      batch.update(budgetRef, {
        spentAmount: increment(amountDifference)
      });
    }

    await batch.commit();
  } catch (e) {
    console.error("Error updating expense:", e);
    throw new Error("Failed to update expense.");
  }
}

/**
 * Deletes a single expense and its receipt, and decrements the budget's spent amount.
 * @param expenseId The ID of the expense to delete.
 * @param budgetId The ID of the parent budget.
 * @param amount The amount of the expense being deleted.
 * @param storagePath The path to the receipt in Firebase Storage, if it exists.
 */
export async function deleteExpense(expenseId: string, budgetId: string, amount: number, storagePath?: string) {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }
  
  const expenseRef = doc(db, "expenses", expenseId);
  const budgetRef = doc(db, "budgets", budgetId);

  try {
    if (storagePath) {
      await deleteFileFromStorage(storagePath);
    }
    
    const batch = writeBatch(db);
    batch.delete(expenseRef);
    batch.update(budgetRef, {
        spentAmount: increment(-amount)
    });

    await batch.commit();
  } catch (e) {
    console.error("Error deleting expense:", e);
    throw new Error("Failed to delete expense.");
  }
}


// --- SAVINGS GOALS ---

type AddGoalData = Omit<SavingsGoal, 'id' | 'currentAmount' | 'deadline' | 'createdAt'> & {
  deadline: Date;
};

/**
 * Adds a new savings goal document to the 'savingsGoals' collection in Firestore.
 * @param goalData The data for the new savings goal.
 * @returns A promise that resolves with the new document reference.
 */
export async function addSavingsGoal(goalData: AddGoalData) {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }
  try {
    const docRef = await addDoc(collection(db, "savingsGoals"), {
      ...goalData,
      deadline: Timestamp.fromDate(goalData.deadline),
      currentAmount: 0,
      createdAt: serverTimestamp(),
    });
    return docRef;
  } catch (e) {
    console.error("Error adding savings goal: ", e);
    throw new Error("Failed to add savings goal to Firestore.");
  }
}

/**
 * Listens for real-time updates to a user's savings goals.
 * @param userId The ID of the user whose goals to fetch.
 * @param callback A function to call with the updated goals list.
 * @returns An unsubscribe function to stop listening for updates.
 */
export function onGoalsUpdate(userId: string, callback: (goals: SavingsGoal[]) => void) {
  if (!db) {
    console.error("Firestore is not initialized.");
    return () => {};
  }
  
  const q = query(collection(db, "savingsGoals"), where("userId", "==", userId));

  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const goals: SavingsGoal[] = [];
    querySnapshot.forEach((doc) => {
      goals.push({ id: doc.id, ...doc.data() } as SavingsGoal);
    });
    callback(goals);
  }, (error) => {
    console.error("Error listening to savingsGoals collection: ", error);
  });

  return unsubscribe;
}

/**
 * Listens for real-time updates to a single savings goal.
 * @param goalId The ID of the savings goal to fetch.
 * @param callback A function to call with the updated goal data.
 * @returns An unsubscribe function to stop listening for updates.
 */
export function onGoalUpdate(goalId: string, callback: (goal: SavingsGoal | null) => void) {
  if (!db) {
    console.error("Firestore is not initialized.");
    return () => {};
  }

  const docRef = doc(db, "savingsGoals", goalId);

  const unsubscribe = onSnapshot(docRef, (docSnap) => {
    if (docSnap.exists()) {
      callback({ id: docSnap.id, ...docSnap.data() } as SavingsGoal);
    } else {
      console.log("No such savings goal document!");
      callback(null);
    }
  }, (error) => {
    console.error("Error listening to savings goal document: ", error);
    callback(null);
  });

  return unsubscribe;
}

/**
 * Deletes a savings goal and all its associated records and screenshots.
 * @param goalId The ID of the savings goal to delete.
 * @param userId The ID of the user who owns the goal.
 */
export async function deleteSavingsGoal(goalId: string, userId: string) {
  if (!db) {
    throw new Error("Firestore is not initialized.");
  }

  const goalRef = doc(db, "savingsGoals", goalId);
  const recordsQuery = query(
    collection(db, "savingsRecords"), 
    where("goalId", "==", goalId),
    where("userId", "==", userId)
  );

  try {
    const batch = writeBatch(db);
    const recordsSnapshot = await getDocs(recordsQuery);

    const deletePromises = recordsSnapshot.docs.map(doc => {
        const record = doc.data() as SavingsRecord;
        if (record.storagePath) {
            return deleteFileFromStorage(record.storagePath);
        }
        return Promise.resolve();
    });
    
    await Promise.all(deletePromises);
    
    recordsSnapshot.forEach(doc => batch.delete(doc.ref));
    batch.delete(goalRef);
    await batch.commit();

  } catch (e) {
    console.error("Error deleting savings goal: ", e);
    throw new Error("Failed to delete savings goal.");
  }
}

// --- SAVINGS RECORDS ---

type AddSavingsRecordData = Omit<SavingsRecord, 'id' | 'date' | 'goalId'>;
/**
 * Adds a new savings record. Does NOT update the goal total.
 * @param goalId The ID of the goal this record belongs to.
 * @param recordData The data for the new savings record.
 * @returns The ID of the newly created record document.
 */
export async function addSavingsRecord(goalId: string, recordData: AddSavingsRecordData): Promise<string> {
  if (!db) throw new Error("Firestore is not initialized.");

  const recordCollRef = collection(db, "savingsRecords");
  const docRef = await addDoc(recordCollRef, {
    ...recordData,
    goalId: goalId,
    date: serverTimestamp(),
  });
  return docRef.id;
}


type UpdateSavingsRecordData = Partial<Omit<SavingsRecord, 'id' | 'date' | 'goalId' | 'userId'>>;
/**
 * Updates an existing savings record and adjusts the parent goal's current amount.
 * @param recordId The ID of the record to update.
 * @param goalId The ID of the parent goal.
 * @param oldAmount The original amount of the record before updating.
 * @param newRecordData The new data for the record.
 */
export async function updateSavingsRecord(recordId: string, goalId: string, oldAmount: number, newRecordData: UpdateSavingsRecordData) {
  if (!db) throw new Error("Firestore is not initialized.");

  const recordRef = doc(db, "savingsRecords", recordId);
  const goalRef = doc(db, "savingsGoals", goalId);

  const finalUpdateData: { [key: string]: any } = {};
  if (newRecordData.description !== undefined) finalUpdateData.description = newRecordData.description;
  if (newRecordData.amount !== undefined) finalUpdateData.amount = newRecordData.amount;
  if (newRecordData.screenshotUrl !== undefined) finalUpdateData.screenshotUrl = newRecordData.screenshotUrl;
  if (newRecordData.storagePath !== undefined) finalUpdateData.storagePath = newRecordData.storagePath;

  const amountDifference = (newRecordData.amount ?? oldAmount) - oldAmount;

  const batch = writeBatch(db);
  if (Object.keys(finalUpdateData).length > 0) {
    batch.update(recordRef, finalUpdateData);
  }
  if (amountDifference !== 0) {
    batch.update(goalRef, { currentAmount: increment(amountDifference) });
  }
  await batch.commit();
}


/**
 * Deletes a savings record and its screenshot, and decrements the goal's current amount.
 * @param recordId The ID of the record to delete.
 * @param goalId The ID of the parent goal.
 * @param amount The amount of the record being deleted.
 * @param storagePath The path to the screenshot in Firebase Storage, if it exists.
 */
export async function deleteSavingsRecord(recordId: string, goalId: string, amount: number, storagePath?: string) {
  if (!db) throw new Error("Firestore is not initialized.");

  const recordRef = doc(db, "savingsRecords", recordId);
  const goalRef = doc(db, "savingsGoals", goalId);
  
  if (storagePath) {
    await deleteFileFromStorage(storagePath);
  }

  const batch = writeBatch(db);
  batch.delete(recordRef);
  batch.update(goalRef, { currentAmount: increment(-amount) });
  await batch.commit();
}


/**
 * Listens for real-time updates to savings records for a specific goal.
 * This query requires a composite index on (userId, goalId).
 * @param goalId The ID of the goal whose records to fetch.
 * @param userId The ID of the currently authenticated user.
 * @param callback A function to call with the updated records list.
 * @returns An unsubscribe function to stop listening for updates.
 */
export function onSavingsRecordsUpdate(goalId: string, userId: string, callback: (records: SavingsRecord[]) => void) {
    if (!db) {
        console.error("Firestore is not initialized.");
        return () => {};
    }

    const q = query(
      collection(db, "savingsRecords"),
      where("userId", "==", userId),
      where("goalId", "==", goalId)
    );

    const unsubscribe = onSnapshot(q, (querySnapshot) => {
        const records: SavingsRecord[] = [];
        querySnapshot.forEach((doc) => {
            records.push({ id: doc.id, ...doc.data() } as SavingsRecord);
        });
        callback(records);
    }, (error) => {
        console.error("Error listening to savings records collection: ", error);
    });

    return unsubscribe;
}

    